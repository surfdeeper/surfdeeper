---
import Layout from '../layouts/Layout.astro';
import { execSync } from 'child_process';
import { readdirSync, statSync } from 'fs';
import { join } from 'path';
import { getCollection } from 'astro:content';
import sections from '../content/guides/_sections.json';
import '../styles/homepage.css';

// Get all surf spots for the map preview
const spots = await getCollection('spots');

// Get all guides and organize by section
const allGuides = await getCollection('guides');
const guidesBySection: Record<string, Array<{ slug: string; title: string; url: string }>> = {};

// Group guides by their section (first part of slug)
for (const guide of allGuides) {
  const slugParts = guide.slug.split('/');
  const section = slugParts[0];
  const pageName = slugParts[1];
  
  // Skip index pages
  if (pageName === 'index') continue;
  
  if (!guidesBySection[section]) {
    guidesBySection[section] = [];
  }
  
  guidesBySection[section].push({
    slug: guide.slug,
    title: guide.data.title,
    url: `/guide/${guide.slug}`
  });
}

// Fetch recent git commits during build
let recentCommits: Array<{ hash: string; date: string; isoDate: string; message: string; url: string }> = [];
try {
  const gitLog = execSync(
    'git log -5 --pretty=format:"%h|%ai|%s"',
    { encoding: 'utf-8' }
  );
  recentCommits = gitLog.split('\n').map(line => {
    const [hash, date, message] = line.split('|');
    return {
      hash,
      date: date, // Keep raw ISO date for client-side formatting
      isoDate: date, // Also store as isoDate for clarity
      message,
      url: `https://github.com/surfdeeper/surfdeeper/commit/${hash}`
    };
  });
} catch (error) {
  console.warn('Could not fetch git log:', error);
}

// Fetch recently updated pages
interface UpdatedPage {
  title: string;
  url: string;
  date: string;
  timestamp: number;
  hierarchy: string;
}

let recentlyUpdated: UpdatedPage[] = [];
try {
  const contentPath = 'src/content';
  const allFiles: string[] = [];
  
  // Recursively find all markdown files
  function findMarkdownFiles(dir: string, baseDir: string = dir) {
    const entries = readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join(dir, entry.name);
      if (entry.isDirectory()) {
        findMarkdownFiles(fullPath, baseDir);
      } else if (entry.name.endsWith('.md') && entry.name !== 'README.md') {
        allFiles.push(fullPath);
      }
    }
  }
  
  findMarkdownFiles(contentPath);
  
  // Get last modified date for each file from git
  const filesWithDates: UpdatedPage[] = [];
  
  for (const filePath of allFiles) {
    try {
      const gitDate = execSync(
        `git log -1 --format="%ai" -- "${filePath}"`,
        { encoding: 'utf-8' }
      ).trim();
      
      if (gitDate) {
        const timestamp = new Date(gitDate).getTime();
        
        // Extract title, hierarchy, and create URL
        let url = '';
        let title = '';
        let hierarchy = '';
        
        if (filePath.includes('content/guides/')) {
          const match = filePath.match(/content\/guides\/([^/]+)\/([^/]+)\.md$/);
          if (match) {
            const [, category, slug] = match;
            const categoryFormatted = category.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            // Handle index pages specially
            if (slug === 'index') {
              url = `/guide/${category}`;
              title = categoryFormatted;
              hierarchy = 'Guide';
            } else {
              url = `/guide/${category}/${slug}`;
              title = slug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
              hierarchy = `Guide > ${categoryFormatted}`;
            }
          }
          } else if (filePath.includes('content/spots/')) {
          const match = filePath.match(/content\/spots\/([^/]+)\.md$/);
          if (match) {
            const slug = match[1];
            url = `/spots/${slug}`;
            title = slug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            hierarchy = 'Spot';
          }
        }
        
        if (url && title) {
          filesWithDates.push({
            title,
            url,
            date: gitDate, // Keep raw ISO date for client-side formatting
            timestamp,
            hierarchy
          });
        }
      }
    } catch (err) {
      // Skip files not in git yet
      continue;
    }
  }
  
  // Sort by timestamp (most recent first) and take top 5
  recentlyUpdated = filesWithDates
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, 5);
    
} catch (error) {
  console.warn('Could not fetch recently updated pages:', error);
}
---

<Layout title="Surf Deeper" description="Open source surfing guide for skills and spots. Community-driven knowledge for surfers of all levels.">
  <div class="homepage-wrapper">
    <div class="marquee-container">
      <div class="marquee" id="surf-ticker">
        <span id="ticker-content">Loading surf conditions...</span>
      </div>
    </div>

    <div class="three-column-layout">
      <!-- Main Content -->
      <section class="content">
    <div class="main-content-grid">
      <div class="map-preview-section">
        <div id="map-preview" class="map-preview-container">
          <div id="spot-list-panel-homepage" class="spot-list-panel-homepage">
            <h3>Spots on Map</h3>
            <ul id="spot-list-homepage"></ul>
          </div>
        </div>
      </div>
    </div>
      </section>

      <!-- Left Sidebar -->
      <aside class="left-sidebar">
        <div class="sidebar-section">
          <h3>üèÑ Skills Guide</h3>
          <ul class="sidebar-links nested-guide">
            {Object.entries(sections)
              .sort(([, a], [, b]) => a.order - b.order)
              .map(([slug, section]) => {
                const guides = guidesBySection[slug] || [];
                const visibleGuides = guides.slice(0, 3);
                const remainingCount = guides.length - 3;
                
                return (
                  <li class="section-item">
                    <a href={`/guide/${slug}`} class="section-link">{section.label}</a>
                    {guides.length > 0 && (
                      <ul class="nested-links">
                        {visibleGuides.map(guide => (
                          <li><a href={guide.url}>{guide.title}</a></li>
                        ))}
                        {remainingCount > 0 && (
                          <li class="more-items">
                            <a href={`/guide/${slug}`}>{remainingCount} more ‚Üí</a>
                          </li>
                        )}
                      </ul>
                    )}
                  </li>
                );
              })
            }
          </ul>
          <div style="margin-top: 1rem; text-align: center;">
            <a href="/guide" style="color: #00ff88; text-decoration: none; font-size: 0.9rem;">Browse All ‚Üí</a>
          </div>
        </div>
      </aside>

      <!-- Right Sidebar -->
      <aside class="right-sidebar">
        <div class="sidebar-section">
          <h3>üí° About</h3>
          <p style="color: #00ff88; opacity: 0.9; font-size: 0.9rem; line-height: 1.6; margin: 0;"><strong>Free and open source</strong> ‚Äî Built by surfers, for surfers. <a href="/contribute" style="color: #00ff88; text-decoration: underline; text-underline-offset: 3px;">Contribute your knowledge</a> to help others learn and progress.</p>
        </div>

        <div class="sidebar-section surf-wisdom">
          <h3>üßò Surf Wisdom</h3>
          <p class="wisdom-quote">"The best surfer out there is the one having the most fun."</p>
          <p class="wisdom-quote">"You can't stop the waves, but you can learn to surf."</p>
        </div>

        {recentlyUpdated.length > 0 && (
          <div class="sidebar-section updates-section">
            <h3>üìù Recently Updated</h3>
            <ul class="updates-list">
              {recentlyUpdated.slice(0, 4).map(page => (
                <li class="update-item">
                  <a href={page.url} class="update-link">
                    <span class="page-hierarchy">{page.hierarchy}</span>
                    <span class="page-title">{page.title}</span>
                  </a>
                  <span class="update-date" data-timestamp={page.date}>{page.date}</span>
                </li>
              ))}
            </ul>
          </div>
        )}

        {recentCommits.length > 0 && (
          <div class="sidebar-section updates-section">
            <h3>üî® Recent Commits</h3>
            <ul class="updates-list">
              {recentCommits.slice(0, 3).map(commit => (
                <li class="update-item">
                  <a href={commit.url} target="_blank" rel="noopener noreferrer" class="update-link commit-link">
                    {commit.message.length > 60 ? commit.message.substring(0, 60) + '...' : commit.message}
                  </a>
                  <span class="update-date" data-timestamp={commit.isoDate}>{commit.date}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </aside>
    </div>
  </div>
</Layout>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="" defer></script>

<script
  type="application/json"
  id="spots-data"
  set:html={JSON.stringify(spots.map((s) => ({
    title: s.data.title,
    description: s.data.description || '',
    latitude: s.data.latitude,
    longitude: s.data.longitude,
    slug: s.slug,
  })))}
></script>

<script>
  import { DEFAULT_THEME_HOMEPAGE } from '../config/map-constants';
  import { getStoredTheme } from '../utils/leaflet-setup';
  import { getTheme, addThemeSwitcherToMap } from '../utils/map-theme-switcher';

  interface SpotData {
    title: string;
    description: string;
    latitude: number;
    longitude: number;
    slug: string;
  }

  function initMapPreview() {
    if (!(window as any).L) {
      requestAnimationFrame(initMapPreview);
      return;
    }

    const mapContainer = document.getElementById('map-preview');
    if (!mapContainer) return;
    
    const dataElement = document.getElementById('spots-data');
    if (!dataElement) return;
    
    let spots: SpotData[] = [];
    try {
      const json = dataElement.textContent || '[]';
      spots = JSON.parse(json);
    } catch (error) {
      console.error('Failed to parse spots JSON:', error);
      return;
    }

    // Get the user's preferred theme or use default
    const currentThemeId = getStoredTheme(DEFAULT_THEME_HOMEPAGE);
    const theme = getTheme(currentThemeId, DEFAULT_THEME_HOMEPAGE);

    const L = (window as any).L;
    
    // Initialize map after a brief delay to ensure container has proper dimensions
    setTimeout(() => {
      const map = L.map('map-preview', {
        scrollWheelZoom: false,
        dragging: true,
        zoomControl: true,
        backgroundColor: '#1a1f2e'
      });
      
      // Add tiles with the selected theme
      const tiles = L.tileLayer(theme.url, {
        attribution: theme.attribution,
        maxZoom: theme.maxZoom,
        className: 'map-tiles',
        ...(theme.subdomains ? { subdomains: theme.subdomains } : {})
      });
      tiles.addTo(map);
      map._tileLayer = tiles;

      // Add theme switcher control
      addThemeSwitcherToMap(map, DEFAULT_THEME_HOMEPAGE, 'topright');

      // Sort spots alphabetically for consistent numbering
      const sortedSpots = [...spots].sort((a, b) => a.title.localeCompare(b.title));
      
      sortedSpots.forEach((spot, index) => {
        if (typeof spot.latitude === 'number' && typeof spot.longitude === 'number') {
          const spotNumber = index + 1;
          
          // Create numbered marker with floating label
          const icon = L.divIcon({
            className: 'numbered-marker-with-label-homepage',
            html: `
              <div class="marker-with-label-homepage">
                <div class="marker-badge-homepage">${spotNumber}</div>
                <div class="marker-label-homepage">${spot.title}</div>
                <div class="marker-pointer-homepage"></div>
              </div>
            `,
            iconSize: [null, null],
            iconAnchor: [18, 32],
            popupAnchor: [0, -32]
          });
          
          const marker = L.marker([spot.latitude, spot.longitude], { icon }).addTo(map);
          const popup = `
            <div style="font-family: inherit;">
              <b>${spot.title}</b>
              ${spot.description ? `<br/>${spot.description}` : ''}
              <div style="margin-top: 0.75rem; padding-top: 0.5rem; border-top: 1px solid rgba(0, 255, 136, 0.2);">
                <a href="/spots/${spot.slug}" style="display: inline-block; color: #0f172a; background-color: #00ff88; font-size: 0.95rem; font-weight: 600; text-decoration: none; padding: 0.5rem 1rem; border-radius: 4px; text-align: center;">View Spot ‚Üí</a>
              </div>
            </div>
          `;
          marker.bindPopup(popup);
          marker.spotData = spot;
          marker.spotNumber = spotNumber;
        }
      });

      // Set view to show entire Santa Cruz to Bolinas coastline
      map.setView([37.44, -122.36], 9);
      
      // Force map to recalculate size after initialization
      setTimeout(() => {
        map.invalidateSize();
      }, 100);
    }, 50); // End of setTimeout for map initialization
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    initMapPreview();
  } else {
    document.addEventListener('DOMContentLoaded', initMapPreview);
  }
</script>

<script is:inline>
  // Format timestamps to user's local timezone
  function formatTimestamps() {
    const dateElements = document.querySelectorAll('.update-date[data-timestamp]');
    
    dateElements.forEach(element => {
      const isoDate = element.getAttribute('data-timestamp');
      if (!isoDate) return;
      
      try {
        const date = new Date(isoDate);
        
        // Format the date in user's local timezone
        const formattedDate = date.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric',
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
        
        // Get the timezone abbreviation
        const timezone = date.toLocaleTimeString('en-US', {
          timeZoneName: 'short'
        }).split(' ').pop();
        
        // Update the element with formatted date and timezone
        element.textContent = `${formattedDate} ${timezone}`;
      } catch (error) {
        console.error('Error formatting date:', error);
      }
    });
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    formatTimestamps();
  } else {
    document.addEventListener('DOMContentLoaded', formatTimestamps);
  }
</script>

<script is:inline>
  // Surf conditions ticker
  async function fetchMarineConditions(latitude, longitude) {
    try {
      const marineUrl = new URL('https://marine-api.open-meteo.com/v1/marine');
      marineUrl.searchParams.set('latitude', latitude.toString());
      marineUrl.searchParams.set('longitude', longitude.toString());
      marineUrl.searchParams.set('hourly', [
        'wave_height',
        'wave_period',
        'wave_direction',
        'swell_wave_height',
        'swell_wave_period',
        'swell_wave_direction'
      ].join(','));
      marineUrl.searchParams.set('forecast_days', '1');

      const weatherUrl = new URL('https://api.open-meteo.com/v1/forecast');
      weatherUrl.searchParams.set('latitude', latitude.toString());
      weatherUrl.searchParams.set('longitude', longitude.toString());
      weatherUrl.searchParams.set('hourly', 'wind_speed_10m,wind_direction_10m');
      weatherUrl.searchParams.set('forecast_days', '1');

      const [marineResponse, weatherResponse] = await Promise.all([
        fetch(marineUrl.toString()),
        fetch(weatherUrl.toString())
      ]);

      if (!marineResponse.ok || !weatherResponse.ok) {
        throw new Error('API error');
      }

      const marineData = await marineResponse.json();
      const weatherData = await weatherResponse.json();
      
      const marineHourly = marineData.hourly;
      const weatherHourly = weatherData.hourly;
      const idx = 0;

      return {
        waveHeight: marineHourly.wave_height[idx] || 0,
        wavePeriod: marineHourly.wave_period[idx] || 0,
        waveDirection: marineHourly.wave_direction[idx] || 0,
        swellHeight: marineHourly.swell_wave_height[idx] || 0,
        swellPeriod: marineHourly.swell_wave_period[idx] || 0,
        swellDirection: marineHourly.swell_wave_direction[idx] || 0,
        windSpeed: weatherHourly.wind_speed_10m[idx] || 0,
        windDirection: weatherHourly.wind_direction_10m[idx] || 0,
        timestamp: marineHourly.time[idx] || new Date().toISOString(),
      };
    } catch (error) {
      console.error('Failed to fetch marine conditions:', error);
      return null;
    }
  }

  function degreesToCardinal(degrees) {
    const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
    const index = Math.round(degrees / 22.5) % 16;
    return directions[index];
  }

  function metersToFeet(meters) {
    return meters * 3.28084;
  }

  function kmhToMph(kmh) {
    return kmh * 0.621371;
  }

  // Random sayings for the ticker
  const surfSayings = [
    "ü§ô The best surfer is the one having the most fun",
    "üåä You can't stop the waves, but you can learn to surf",
    "üèÑ No one is born knowing how to surf - we all started as kooks",
    "üí° Open source surfing - built by surfers, for surfers",
    "‚ú® Knowledge shared is knowledge multiplied",
    "üìö Got surf wisdom? <a href='/contribute' style='color: #00ff88; text-decoration: underline;'>Contribute a guide</a>",
    "üéØ Every wipeout is a lesson, every wave is practice",
    "üåÖ Dawn patrol: where legends are made and coffee is essential",
    "ü¶à Spoiler: You're more likely to drown than get attacked by a shark",
    "üßò Surfing is 90% paddling, 10% riding, 100% worth it",
    "üå¥ Free surf spots, free guides, free knowledge - that's the SurfDeeper way",
    "üí™ Stronger paddling = more waves = more stoke",
    "üé® Every wave is different - surf like you mean it",
    "üî• Share your local knowledge - help the next generation",
    "üåü The ocean doesn't care about your resume",
    "üöÄ Progression > Perfection",
    "üé™ Kook life chose us, then we evolved",
    "üåä Reading waves is an art, catching them is a science",
    "üèÜ The only competition is with yesterday's version of yourself",
    "üéì Learn from everyone, even the groms",
    "üíé Secret spots aren't so secret anymore - respect the locals",
    "‚ö° When in doubt, paddle out (but know your limits)",
    "üîÆ Forecast says flat? Perfect time to work on your fitness",
    "üé≠ Style is temporary, stoke is forever",
    "üåà There's always a wave for your skill level",
    "üéØ Small wave = big opportunity to practice",
    "üß† Smart surfing beats strong surfing every time",
    "üí´ The lineup is a classroom, the ocean is the teacher",
    "üé™ Every surf session is a gift",
    "üé® Make this resource better - <a href='/contribute' style='color: #00ff88; text-decoration: underline;'>add your knowledge</a>",
    "üåä Surf therapy: cheaper than a psychologist, more effective",
    "üîß DIY ding repair: because surf shops close at 6pm",
    "‚òÄÔ∏è Sunscreen today, skin tomorrow",
    "üéµ The sound of waves is nature's playlist",
    "üèãÔ∏è Shoulder health = surf longevity",
    "üß≠ Check the tide, read the swell, respect the ocean",
    "üé¨ Video review yourself - it's humbling and helpful",
    "üåç Protect the ocean, it's the only one we've got",
    "üíß Hydrate before you paddle, thank yourself later",
    "üé™ Worst day surfing > best day working",
    "üî• Got tips? Got spots? Got stories? <a href='/contribute' style='color: #00ff88; text-decoration: underline;'>Share them here</a>",
    "üéØ Position beats power in the lineup",
    "üåä Wave count doesn't matter if you're smiling",
    "üßò Breathe, relax, paddle, repeat",
    "‚öôÔ∏è Board maintenance: love your stick, it loves you back",
    "üéì Every expert was once a beginner",
    "üí™ Paddle fitness is the secret weapon",
    "üåü Respect the ocean, respect each other",
    "üé® Your style, your wave, your journey",
    "üîÆ Tide turning? Time to adjust",
    "üé™ The stoke is real, the community is real, the help is free",
    "üì¢ Surf lie: Just one more wave",
    "üì¢ Surf lie: Should've been here 10 minutes ago",
    "üì¢ Surf lie: It's not crowded",
    "üì¢ Surf lie: Tide will fix it",
    "üì¢ Surf lie: Last one, I swear",
    "üì¢ Surf lie: I'll sit wide",
    "üì¢ Surf lie: It's 4-6 and clean - in Surfline voice",
    "üì¢ Surf lie: That section was makeable",
    "üì¢ Surf lie: I'm not cold",
    "üì¢ Surf lie: You didn't burn me"
  ];

  function getRandomSaying() {
    return surfSayings[Math.floor(Math.random() * surfSayings.length)];
  }

  function calculateDistance(lat1, lon1, lat2, lon2) {
    // Haversine formula for distance between two points
    const R = 6371; // Radius of Earth in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c; // Distance in km
  }

  async function updateSurfTicker() {
    const tickerContent = document.getElementById('ticker-content');
    if (!tickerContent) return;

    // Surf spots to check (using actual spots from the site)
    const spots = [
      { name: 'Ocean Beach', slug: 'ocean-beach', lat: 37.7699, lon: -122.5109 },
      { name: 'Linda Mar', slug: 'linda-mar', lat: 37.5989, lon: -122.5001 },
      { name: 'Pleasure Point', slug: 'pleasure-point', lat: 36.9651, lon: -121.9698 },
      { name: 'Bolinas', slug: 'bolinas', lat: 37.9079, lon: -122.6859 }
    ];

    let closestSpot = spots[0]; // Default to first spot

    // Try to get user's location to find closest spot
    try {
      const position = await new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          timeout: 5000,
          maximumAge: 600000 // Cache for 10 minutes
        });
      });
      
      const userLat = position.coords.latitude;
      const userLon = position.coords.longitude;
      
      // Find closest spot
      let minDistance = Infinity;
      for (const spot of spots) {
        const distance = calculateDistance(userLat, userLon, spot.lat, spot.lon);
        if (distance < minDistance) {
          minDistance = distance;
          closestSpot = spot;
        }
      }
    } catch (error) {
      // Geolocation failed or denied, use default spot
      console.log('Using default surf spot (geolocation unavailable)');
    }

    // Fetch conditions for closest spot only
    const conditions = await fetchMarineConditions(closestSpot.lat, closestSpot.lon);
    
    if (!conditions) {
      tickerContent.innerHTML = getRandomSaying() + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚Äî&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' + getRandomSaying();
      initMarqueeAnimation();
      return;
    }

    // Build surf report for the one closest spot
    const waveHeightFt = metersToFeet(conditions.waveHeight).toFixed(1);
    const windSpeedMph = kmhToMph(conditions.windSpeed).toFixed(0);
    const windDir = degreesToCardinal(conditions.windDirection);
    const swellDir = degreesToCardinal(conditions.swellDirection);
    const period = conditions.swellPeriod.toFixed(0);
    
    const surfReport = `<a href="/spots/${closestSpot.slug}" style="color: #00ff88; text-decoration: none; border-bottom: 1px dotted #00ff88; font-weight: 600;">${closestSpot.name}</a>: ${waveHeightFt}ft @ ${period}s ${swellDir} ‚Ä¢ Wind ${windSpeedMph}mph ${windDir}`;
    
    // Get 2 random sayings
    const saying1 = getRandomSaying();
    const saying2 = getRandomSaying();
    
    // Build full ticker with surf report + random sayings
    const fullMessage = `${surfReport}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚Äî&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${saying1}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚Äî&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${saying2}`;
    
    // Duplicate content for seamless scrolling
    tickerContent.innerHTML = fullMessage + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚Äî&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' + fullMessage;
    
    // Restart marquee animation after content update
    initMarqueeAnimation();
  }

  // JavaScript-based marquee animation for mobile compatibility
  let animationFrameId = null;
  
  function initMarqueeAnimation() {
    const tickerContent = document.getElementById('ticker-content');
    if (!tickerContent) return;
    
    // Cancel any existing animation
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
    
    // Check if user prefers reduced motion
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) {
      return; // Don't animate if user prefers reduced motion
    }
    
    let position = 0;
    const speed = 0.5; // pixels per frame (adjust for speed)
    
    function animate() {
      // Get the width of the content
      const contentWidth = tickerContent.offsetWidth;
      
      // Move the content
      position -= speed;
      
      // Reset position when we've scrolled half the content (due to duplication)
      if (Math.abs(position) >= contentWidth / 2) {
        position = 0;
      }
      
      // Apply transform
      tickerContent.style.transform = `translateX(${position}px)`;
      
      // Continue animation
      animationFrameId = requestAnimationFrame(animate);
    }
    
    // Start the animation
    animationFrameId = requestAnimationFrame(animate);
  }

  // Initial update and start animation
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    updateSurfTicker();
  } else {
    document.addEventListener('DOMContentLoaded', updateSurfTicker);
  }

  // Refresh every 15 minutes
  setInterval(updateSurfTicker, 15 * 60 * 1000);
</script>

